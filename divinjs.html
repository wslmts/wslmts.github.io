<html>
    <head></head>
    <title>webpack</title>
    <link type="text/css" rel="stylesheet" href="./css/main.css"/>
    <script src="vue.js"></script>
    </style>
    <body>
        <div id="app">
         <ol>
            <li>
              <h3>对象在数值环境中特殊情况</h3>
              <pre>
                1)先调用对象的valueof()，返回对象自身的值；valueof()仅仅能返回自身值，不会转换值的类型
                2)如果对象自身值不是数值，则继续调用tostring()，再调用parseFloat()或parseInt()转为数值；
                3）以上都不行，或者值返回NaN，则通过强制方法把对象转为数值，再不成功，返回NaN;
                var a=new Boolean(true)
                console.log(a.valueOf()) // true
                console.log(typeof a.valueOf()) // Boolean
              </pre>
            </li>
            <li>
              <h3>数组在数值环境中特殊情况</h3>
              <pre>
                1)空数组，会先调用tostring()=》“”，再将空字符串转为数值0
                2)如果数组仅包含一个数字元素，则转换为该数字的数值；[3]*2=6
                3）数组包含多个元素或者仅包含一个非数字元素，返回NaN;
              </pre>
            </li> 
            <li>
                <h3>数字转字符串</h3>
                <pre>
                  1)小数末尾的0会被清除，（0.001000).toString() // '0.001'
                  2)科学计数法，在条件许可情况下转为浮点数，否则以科学计数法方式输出；
                  例如：(0.0000000001).toString() //"1e-10"
                  (1e-10).toString() //"1e-10"
                  经chrome测试，(1e-6).toString() //"0.000001" 
                  小于-6的均以科学计数法形式输出；
                </pre>
              </li> 
              <li>
                在声明函数时，js会自动建立一个对象，这个对象称为调用对象。在预编译期函数处理是，函数的参数和局部变量将作为调用对象的属性进行存储。
              </li>
              <li>
                在预编译期，js解释器会把代码中的function语句定义为一个函数变量，同时解析函数体内部语句和相关逻辑，
                并存储在函数变量所指向的地址中；然后定义一个与函数同名的属性，并把这个属性赋给函数所在的作用域对象上；
                如果是嵌套函数，则会把这个属性赋给外层函数的调用对象；
              </li>
              <li>
                <pre>
                  var n=1
                  function f(){
                    var n=2
                    var e= new Function('console.log(n);return n')                
                    return e()
                  }
                  console.log(f())//1，1
                  执行结果证明，Function作用域是动态确定的；函数体里的内容在函数调用前并没有执行，
                  即函数内部成员是在函数被处理时定义的，如参数变量、局部变量等；但当函数调用完毕以后将释放所有资源；
                  对于function声明函数来说，依然保存着该函数在预编译时所占据的内存空间；对于匿名函数，则将完全释放；
                  对于函数直接量来说，由于是静态函数，所以会在系统中保存一根函数结构的备份，以备下次调用。
                </pre>
              </li>
              <li>
                形参与函数体内使用var声明的变量一样都属于局部变量，只有在函数被执行时才会被定义。一旦返回会随函数结构一同被注销。
                因此形参一般不占内存，只是在函数调用时才产生内存问题，而实参在调用前必须是已经分配内存的。
                如果是普通变量，那么形参在接收值之前，系统会给形参分配新的内存单元，形参的变化与实参无关，这是传值；
                如果传递的是数组名或者引用地址，则传递的是地址值，则形参实参共享内存单元，这是传址。
              </li>
         </ol>
        </div>  
        <script>
            new Vue({
                el:"#app",      
                data:{
                    num:29
                },
                computed:{
                    imgs(){
                        let a=[]
                        for(let i=1;i<=this.num;i++){
                           a.push("img/webkit"+i+".png")
                        } 
                        return a
                    }
                }
            })
           </script>     
    </body>
</html>
<html>
  <head>
    <link type="text/css" rel="stylesheet" href="./css/main.css"/> 
    <style>
      table{
          border-collapse: collapse;
      }
     
    </style>
    <script src="vue.js"></script>
  </head>
  <body>
    <div id="app">                 
    <table border="1">
        <tr>
            <th>类型</th><th>用途</th>
        </tr>
        <tr>
            <td>A</td>
            <td>IP 地址是保存在 A 记录中,注册了A类型的记录，都可以作为服务器的域名来使用</td>
        </tr>
        <tr>
            <td>MX</td>
            <td>邮件服务器则是保存在 MX 记录中,当记录类型 为 MX 时，DNS 服务器会在记录中保存两种信息，分别是邮件服务器的域 名和优先级 </td>
        </tr>
        <tr>
            <td>PTR</td>
            <td>根据 IP 地址反查域名</td>
        </tr>
        <tr>
            <td>CNAME</td>
            <td>查询域名相关别名</td>
        </tr>
        <tr>
            <td>NS</td>
            <td>查询 DNS 服务器 IP 地址</td>
        </tr>
        <tr>
            <td>SOA</td>
            <td>查询域名属性信息</td>
        </tr>
    </table>
    <ol>
        <li>
            <pre>
                互联网中有数万台 DNS 服务器，采用下面的办法管理。
                首先，将负责管理下级域的 DNS 服务器的 IP 地址注 册到它们的上级 DNS 服务器中，
                然后上级 DNS 服务器的 IP 地址再注册到 更上一级的 DNS 服务器中，以此类推。
                也就是说，负责管理 lab.glasscom.com 这个域的 DNS 服务器的 IP 地址需要注册到 glasscom.com 域的 DNS 服务器中，
                而 glasscom.com 域的 DNS 服务器的 IP 地址又需要注册到 com 域的 DNS 服务器中。
                这样，我们就可以通过上级 DNS 服务器查询出下级 DNS 服务器的 IP 地址，也就可以向下级 DNS 服务器发送查询请求了。
                似乎 com、jp 这些域(称为顶级域)就是最顶层了， 它们各自负责保存下级 DNS 服务器的信息，但实际上并非如此。
                在互联网 中，com 和 jp 的上面还有一级域，称为根域。根域不像 com、jp 那样有自 己的名字，因此在一般书写域名时经常被省略，
                如果要明确表示根域，应 该像 www.lab.glasscom.com. 这样在域名的最后再加上一个句点，而这个最 后的句点就代表根域。
                不过，一般都不写最后那个句点，因此根域的存在 往往被忽略，但根域毕竟是真实存在的，根域的 DNS 服务器中保管着 com、jp 等的 DNS 服务器的信息。
            </pre>
        </li>
        <li>
            <pre>
                将根域的 DNS 服务器信息保 存在互联网中所有的 DNS 服务器中,这样一来，任何 DNS 服务器就都可 以找到并访问根域 DNS 服务器了。
                因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜 找到位于下层的某台目标 DNS 服务器。
                分配给根域 DNS 服务器 的 IP 地址在全世界仅有 13 个，而且这些地址几乎不发生变化，因此将这 些地址保存在所有的 DNS 服务器中也并不是一件难事。
                实际上，根域 DNS 服务器的相关信息已经包含在 DNS 服务器程序的配置文件中了，因 此只要安装了 DNS 服务器程序，这些信息也就被自动配置好了。
            </pre>
        </li>
        <li>
            <pre>
                服务器上所使用的端口号是根据应用的种类事先规定好的，只要指定了事先规定好的端口号，就可以连接到相应的服务器 程序的套接字。
                也就是说，浏览器访问 Web 服务器时使用 80 号端口，这 是已经规定好的。
                客户端在创建套接字时，协议栈会为这个套接 字随便分配一个端口号 A。接下来，当协议栈执行连接操作时，会将这个随 便分配的端口号通知给服务器
            </pre>
        </li>
        <li>
            <pre>
                路由器和集线器两种不同的转发设备，它们在传输网络包时有 着各自的分工。
                (1)路由器根据目标地址判断下一个路由器的位置 (2)集线器在子网中将网络包传输到下一个路由
                实际上，集线器是按照以太网规则传输包的设备，而路由器是按照 IP 规则传输包的设备，因此我们也可以作如下理解。
                (1)IP 协议根据目标地址判断下一个 IP 转发设备的位置 (2)子网中的以太网协议将包传输到下一个转发设备
                TCP/IP 包包含如下两个头部,
                (a)MAC 头部(用于以太网协议) (b)IP 头部(用于 IP 协议)
                这两个头部分别具有不同的作用。首先，发送方将包的目的地，也就 是要访问的服务器的 IP 地址写入 IP 头部中。
                这样一来，我们就知道这个 包应该发往哪里，IP 协议就可以根据这一地址查找包的传输方向，从而找 到下一个路由器的位置，也就是图 2.16 中的路由器 R1。
                接下来，IP 协议 会委托以太网协议将包传输过去。这时，IP 协议会查找下一个路由器的以 太网地址(MAC 地址)，并将这个地址写入 MAC 头部中。
                这样一来，以太 网协议就知道要将这个包发到哪一个路由器上了。  
            </pre>
        </li>
        <li>
            <pre>
                网络包在传输过程中会经过集线器，集线器是根据以太 网协议工作的设备。
                为了判断包接下来应该向什么地方传输，集线器里有 一张表(用于以太网协议的表)，可根据以太网头部中记录的目的地信息查 出相应的传输方向。
                这张图中只有一个集线器，当存在多个集线器时，网 络包会按顺序逐一通过这些集线器进行传输。
                接下来，包会到达下一个路由器。路由器中有一张 IP 协 议的表，可根据这张表以及 IP 头部中记录的目的地信息查出接下来应该发 往哪个路由器。
                为了将包发到下一个路由器，我们还需要查出下一个路由 器的 MAC 地址，并记录到 MAC 头部中，大家可以理解为改写了 MAC 头 部。
                这样，网络包就又被发往下一个节点了。
            </pre>
        </li>
        <li>
            <pre>
                包收发操作的起点是 TCP 模块委托 IP 模块发送包的操作。这个委托的过程就是 TCP 模块在数据块的前面加上 TCP 头部，
                然后整个传递给 IP 模块，这部分就是网络包的内容。与此同时， TCP 模块还需要指定通信对象的 IP 地址，也就是需要写清楚“将什么内 容发给谁”。
                收到委托后，IP 模块会将包的内容当作一整块数据，在前面加上包含 控制信息的头部。刚才我们讲过，IP 模块会添加 IP 头部和 MAC 头部这两 种头部。
                IP 头部中包含 IP 协议规定的、根据 IP 地址将包发往目的地所需 的控制信息;MAC 头部包含通过以太网的局域网将包传输至最近的路由器所需的控制信息;
                IP 模块负责添加如下两个头部。
                (1) MAC 头部:以太网用的头部，包含 MAC 地址 (2) IP 头部:IP 用的头部，包含 IP 地址;
                接下来，封装好的包会被交给网络硬件，例 如以太网、无线局域网等。不 同形态的硬件名字也不一样，本书将它们统称为网卡。
                传递给网卡的网络 包是由一连串 0 和 1 组成的数字信息，网卡会将这些数字信息转换为电信 号或光信号，并通过网线(或光纤)发送出去，
                然后这些信号就会到达集线 器、路由器等转发设备，再由转发设备一步一步地送达接收方。

                在这个过程中，有几个关键的点。TCP 模块在收发数据时会分为好几 个阶段，并为各个阶段设计了实现相应功能的网络包，
                但 IP 的包收发操作 都是相同的，并不会因包本身而有所区别。因为 IP 模块会将 TCP 头部和 数据块看作一整块二进制数据，
                在执行收发操作时并不关心其中的内容， 也不关心这个包是包含 TCP 头部和数据两者都有呢，还是只有 TCP 头部 而没有数据。
                当然，IP 模块也不关心 TCP 的操作阶段，对于包的乱序和丢 失也一概不知。总之，IP 的职责就是将委托的东西打包送到对方手里，
                或 者是将对方送来的包接收下来，仅此而已。因此，接下来我们要讲的这些 关于 IP 的工作方式，可适用于任何 TCP 委派的收发操作;
            </pre>
        </li>
        <li>
            <pre>
                具体来说，中断的工作过程是这样的。首先，网卡向扩展总线中的中 断信号线发送信号，该信号线通过计算机中的中断控制器连接到 CPU。
                当 产生中断信号时，CPU 会暂时挂起正在处理的任务，切换到操作系统中的 中断处理程序 B。
                然后，中断处理程序会调用网卡驱动，控制网卡执行相应 的接收操作。  
                中断是有编号的，网卡在安装的时候就在硬件中设置了中断号，在中 断处理程序中则将硬件的中断号和相应的驱动程序绑定。
                例如，假设网卡 的中断号为 11，则在中断处理程序中将中断号 11 和相应的网卡驱动绑定 起来，当网卡发起中断时，就会自动调用网卡驱动了。
            </pre>
        </li>
        <li>
            <pre>
                如果接收方 IP 地址不是自己的地址，那一定是发生了什么错误。客户 端计算机不负责对包进行转发，因此不应该收到不是发给自己的包 C。
                当发生这样的错误时，IP 模块会通过 ICMP 消息将错误告知发送方；
            </pre>
        </li>
        <li>
            <pre>
                网络包从客户端计算机发出之后，要经过集线器、交 换机和路由器最终进入互联网。实际上，我们家里用的路由器已经集成了 集线器和交换机的功能
            </pre>
        </li>
        <li>
            <pre>
               当信号到达集线器后，会被广播到整个网络中。以太网的基本架构就是将包发到所有的设备，然后由设备根据接收方 MAC 地址来判断应该接 收哪些包，
               而集线器就是这一架构的忠实体现，它就是负责按照以太网的 基本架构将信号广播出去。
               由于集线器只是原封不动地将信号广播出去，所以即便信号受到噪声 的干扰发生了失真，也会原样发送到目的地。
               这时，接收信号的设备，也 就是交换机、路由器、服务器等，会在将信号转换成数字信息后通过 FCSA 校验发现错误，并将出错的包丢弃。
               当然，丢弃包并不会影响数据的传输， 因为丢弃的包不会触发确认响应。因此协议栈的 TCP 模块会检测到丢包， 并对该包进行重传。
            </pre>
        </li>
        <li>
            <pre>
                交换机的一个端口就相当于计算机上的一块网卡。但交换机的工作方式和网卡有一点不同。网卡本身具有 MAC 地址，
                并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃;相对地，交换机的端口不 核对接收方 MAC 地址，
                而是直接接收所有的包并存放到缓冲区中。因此， 和网卡不同，交换机的端口不具有 MAC 地址   
                将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址 是否已经在 MAC 地址表中有记录了。
                MAC 地址表主要包含两个信息，一 个是设备的 MAC 地址，另一个是该设备连接在交换机的哪个端口上。 
            </pre>
        </li>
        <li>
            <pre>
            目标地址列中的 IP 地 址表示的是子网，但也有一些例外，有时地址本身的子网掩码和路由表 中的子网掩码是不一致的，这是路由聚合的结果。
            路由聚合会将几个子 网合并成一个子网，并在路由表中只产生一条记录。要搞清楚这个问 题，我们还是看一个例子。例如我们现在有 3 个子网，
            分别为10.10.1.0/24、10.10.2.0/24、10.10.3.0/24，路由器 B 需要将包发往这 3 个子 网。在这种情况下，
            路由器 B 的路由表中原本应该有对应这 3 个子网的 3 条记录，但在这个例子中，无论发往任何一个子网，都是通过路由器 A 来 进行转发，
            因此我们可以在路由表中将这 3 个子网合并成 10.10.0.0/16，这 样也可以正确地进行转发，但我们减少了路由表中的记录数量，这就是路 由聚合。
            经过路由聚合，多个子网会被合并成一个子网，子网掩码会发生 变化，同时，目标地址列也会改成聚合后的地址。

            路由表的子网掩码列只表示在匹配网络包目标地址时需要对比的比特数量。
            路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包， 遇到不匹配的包则直接丢弃。
            </pre>
        </li>
        <li>
            <pre>
            完成包接收操作之后，路由器就会丢弃包开头的 MAC 头部。MAC 头 部的作用就是将包送达路由器，其中的接收方 MAC 地址就是路由器端口 的 MAC 地址。
            因此，当包到达路由器之后，MAC 头部的任务就完成了， 于是 MAC 头部就会被丢弃。
            通过路由器转发的网络包，其接收方 MAC 地址为路由器端口的 MAC 地址。
            接下来，路由器会根据 MAC 头部后方的 IP 头部中的内容进行包的转 发操作。 
            </pre>
        </li>
        <li>
            <pre>
            对于没有在访问互联网的内网设备，是无法 从互联网向其发送网络包的。而且即便是正在访问的设备，也只能向和互 联网通信中使用的那个端口发送网络包，
            无法向其他端口发送包。也就是 说，除非公司主动允许，否则是无法从互联网向公司内网发送网络包的。 这种机制具有防止非法入侵的效果。
            不过，有时候我们希望能够从互联网访问公司内网，这需要进行一些 设置才能实现。之所以无法从互联网访问内网，是因为对应表里没有相应 的记录，
            那么我们只要事先手动添加这样的记录就可以了(图 3.19)。一般 来说，用于外网访问的服务器可以放在地址转换设备的外面并为它分配一 个公有地址，
            也可以将服务器的私有地址手动添加到地址转换设备中，这 样就可以从互联网访问到这台具有私有地址的服务器了
            </pre>
        </li>
        <li>
            <h3>服务器端的具体工作过程</h3>
            <pre>
            1.首先，协议栈调用 socket 创建套接字,这一步和客户端是 相同的。
            2.接下来调用 bind 将端口号写入套接字中。在客户端发起 连接的操作中，需要指定服务器端的端口号，这个端口号也就是在这一步 设置的。
            具体的编号是根据服务器程序的种类，按照规则来确定的
            3.设置好端口号之后，协议栈会调用 listen 向套接字写入等待连接状态 这一控制信息。这样一来，套接字就会开始等待来自客户端 的连接网络包。
            4.然后，协议栈会调用 accept 来接受连接。由于等待连接 的模块在服务器程序启动时就已经在运行了，所以在刚启动时，应该还没 有客户端的连接包到达。
            可是，包都没来就调用 accept 接受连接，可能大 家会感到有点奇怪，不过没关系，因为如果包没有到达，就会转为等待包 到达的状态，并在包到达的时候继续执行接受连接操作。
            因此，在执行 accept 的时候，一般来说服务器端都是处于等待包到达的状态，这时应用 程序会暂停运行。在这个状态下，一旦客户端的包到达，就会返回响应包 并开始接受连接操作。
            接下来，协议栈会给等待连接的套接字复制一个副 本，然后将连接对象等控制信息写入新的套接字中
            5.当 accept 结束之后，等待连接的过程也就结束了，这时等待连接模块 会启动客户端通信模块，然后将连接好的新套接字转交给客户端通信模块， 
            由这个模块来负责执行与客户端之间的通信操作。之后的数据收发操作和 刚才说的一样，与客户端的工作过程是相同的。


            其实在这一系列操作中，还有一部分没有讲到，那就是在复制出一个 新的套接字之后，原来那个处于等待连接状态的套接字会怎么样呢?
            其实 它还会以等待连接的状态继续存在，当再次调用 accept，客户端连接包到 达时，它又可以再次执行接受连接操作。
            接受新的连接之后，和刚才一样， 协议栈会为这个等待连接的套接字复制一个新的副本，然后让客户端连接 到这个新的副本套接字上。
            像这样每次为新的连接创建新的套接字就是这 一步操作的一个关键点。如果不创建新副本，而是直接让客户端连接到等 待连接的套接字上，
            那么就没有套接字在等待连接了，这时如果有其他客 户端发起连接就会遇到问题。为了避免出现这样的情况，协议栈采用了这 种创建套接字的新副本，
            并让客户端连接到这个新副本上的方法。


            </pre>
        </li>
        <li>
        <h3>TCP 模块如何处理连接包</h3>
        <pre>
        (1) 协议栈的IP模块会检查IP头部判断是不是发 给 自己 的  
        (2) 判断网络包是否经过分片;
        (3) 将包转交给 TCP 模块或 UDP模块(如果协议号为 06(十六进制)，则将包转交给 TCP 模块;如果是 11(十 六进制)，则转交给 UDP 模块)。

        当 TCP 头部中的控制位 SYN 为 1 时，表示这是一个发起连接的包。这时，TCP 模块会执行接受连接的操作，不过在此之前，需 要先检查包的接收方端口号，
        并确认在该端口上有没有与接收方端口号相 同且正在处于等待连接状态的套接字。如果指定端口号没有等待连接的套接字，则向客户端返回错误通知的包。 
        <span class="red">如果存在等待连接的套接字，则为这个套接字复制一个新的副本，并将发送方 IP 地址、端口号、序号初始值、窗口大小等必要的参数写入这个套接字中，
        同时分配用于发送缓冲区和接收缓冲区的内存空间。然后生成 代表接收确认的 ACK 号，用于从服务器向客户端发送数据的序号初始值， 
        表示接收缓冲区剩余容量的窗口大小，并用这些信息生成 TCP 头部，委托 IP 模块发送给客户端 </span>
        这个包到达客户端之后，客户端会返回表示接收确认的 ACK 号，当 这个 ACK 号返回服务器后，连接操作就完成了。
        这时，服务器端的程序应该进入调用 accept 的暂停状态，当将新套接 字的描述符转交给服务器程序之后，服务器程序就会恢复运行。

        接下来我们来看看进入数据收发阶段之后，当数据包到达时 TCP 模 块是如何处理的
        首先，TCP 模块会检查收到的包对应哪一个套接字。在服务器端，可 能有多个已连接的套接字对应同一个端口号，因此仅根据接收方端口号无 法找到特定的套接字。
        这时我们需要根据 IP 头部中的发送方 IP 地址和接 收方 IP 地址，以及 TCP 头部中的接收方端口号和发送方端口号共 4 种信 息，找到上述 4 种信息全部匹配的套接字
        
        找到 4 种信息全部匹配的套接字之后，TCP 模块会对比该套接字中保 存的数据收发状态和收到的包的 TCP 头部中的信息是否匹配，以确定数据 收发操作是否正常。
        具体来说，就是根据套接字中保存的上一个序号和数 据长度计算下一个序号，并检查与收到的包的 TCP 头部中的序号是否一 致。
        如果两者一致，就说明包正常到达了服务器，没有丢失。这时，TCP 模块会从包中提出数据，并存放到接收缓冲区中，与上次收到的数据块连 接起来。
        这样一来，数据就被还原成分包之前的状态了。
        当收到的数据进入接收缓冲区后，TCP 模块就会生成确认应答的 TCP头部，并根据接收包的序号和数据长度计算出 ACK 号，然后委托 IP 模块 发送给客户端 。
        收到的数据块进入接收缓冲区，意味着数据包接收的操作告一段落了。 接下来，应用程序会调用 Socket 库的 read来获取收到的数据，这时数据会被转交给应用程序。
        如果应用程序不来获取数据，则数据会被 一直保存在缓冲区中，但一般来说，应用程序会在数据到达之前调用 read 等待数据到达，
        在这种情况下，TCP 模块在完成接收操作的同时，就会执 行将数据转交给应用程序的操作。
        然后，控制流程会转移到服务器程序，对收到的数据进行处理，也就 是检查 HTTP 请求消息的内容，并根据请求的内容向浏览器返回相应的数 据。
         
    </pre>
        </li>
        <li>
            <pre>
            在 TCP 协议的规则中，断开操作可以由客户端或服务器任何一方发 起，具体的顺序是由应用层协议决定的。
            Web 中，这一顺序随 HTTP 协议 版本不同而不同，在 HTTP1.0 中，是服务器先发起断开操作。
            这时，服务器程序会调用 Socket 库的 close，TCP 模块会生成一个控 制位 FIN 为 1 的 TCP 头部，并委托 IP 模块发送给客户端。
            当客户端收到这个包之后，会返回一个 ACK 号。接下来客户端调用 close，生成一个 FIN 为 1 的 TCP 头部发给服务器，服务器再返回 ACK 号，这时断开操作 就完成了。
            HTTP1.1 中，是客户端先发起断开操作，这种情况下只要将客 户端和服务器的操作颠倒一下就可以了。
            无论哪种情况，当断开操作完成后，套接字会在经过一段时间后被删除。
            </pre>
        </li>
        <li>
            <h3> Web 服务器程序解释请求消息并作出响应</h3>
            <pre>
                Web 服务器公开的目录其实并不是磁盘上的实际目录，而是虚拟目录，而 URI 中写的就是在这个虚拟目录结构下的路径名。
                因 此，当读取文件时，需要先查询虚拟目录与实际目录的对应关系，并将 URI 转换成实际的文件名后，才能读取文件并返回数据。
                例如：/~user2/sub-user2/sample.html (1) /home/user2/sub-user2/sample.html (2)
                于是，服务器就会根据上述路径从磁盘中读取相应的文件，然后将数 据返回给客户端。
                有些 Web 服务器程序还具有文件名改写功能，只要设置好改写的规 则，当 URI 中的路径符合改写规则时，就可以将 URI 中的文件名改写成其 他的文件名进行访问

                收到请求消息之后，Web 服务器会进行下面的工作。首先，Web 服务 器会检查 URI 指定的文件名，看一看这个文件是不是一个程序。
                这里的判 断方法是在 Web 服务器中事先设置好的，一般是通过文件的扩展名来进行 判断，例如将 .cgi、.php 等扩展名的文件设置为程序，当遇到这些文件时， 
                Web 服务器就会将它们作为程序来对待。也可以设置一个存放程序的目 录，将这个目录下的所有文件都作为程序来对待。此外，还可以根据文件 的属性来进行判断。

                如果判断要访问的文件为程序文件，Web 服务器会委托操作系统运行 这个程序，然后从请求消息中取出数据并交给运行的程序。如果方法为 GET，则将 URI 后面的参数传递给程序;
                如果方法为 POST，则将消息体 中的数据传递给程序
            </pre>
        </li>
        <li>
            <h3>Web 服务器的访问控制</h3>
            <pre>
                Web 服务器的访问控制规则主要有以下 3 种。
                (1)客户端 IP 地址 (2)客户端域名 (3)用户名和密码
                以上规则可针对作为数据源的文件和目录进行设置，当收到客户端的 请求消息时，服务器会根据 URI 判断数据源，并检查数据源对应的访问控 制规则，
                只有允许访问时才读取文件或运行程序。下面我们来看一下设定 访问控制规则时，服务器是如何工作的。

                1.首先是根据客户端 IP 地址设置的规则，这个情况很简单，在调用 accept 接受连接时，就已经知道客户端的 IP 地址了，只要检查其是否允许 访问就可以了。

                2.当根据客户端域名设置规则时，需要先根据客户端 IP 地址查询客户端 域名，这需要使用 DNS 服务器。
                一般我们使用 DNS 服务器都是根据域名 查询 IP 地址，其实根据 IP 地址反查域名也可以使用 DNS 服务器。
                具体来说， 这个过程是这样的。收到客户端的请求消息后，Web 服务器会 委托协议栈告知包的发送方 IP 地址，
                然后用这个 IP 地址生成查询消息并 发送给最近的 DNS 服务器。接下来，DNS 服务器找出负责管 辖该 IP 地址的 DNS 服务器，并将查询转发给它，
                查询到相应 的域名之后返回结果，然后 Web 服务器端的 DNS 服务器再将 结果转发给 Web 服务器。这样一来，我们就可以根据发送方 IP 地址查询到域名。
                接下来，为了保险起见，还需要用这个域名查询一下 IP 地址，看看结果与发送方 IP 地址是否一致。这是因为有一 种在 DNS 服务器上注册假域名的攻击方式，
                因此我们需要进行双重检查,如果两者一致则检查相应的访问控制规则，判断是否允许访问。

                3.Web 服务器提供的密码认证功能时的工作过程
                如果用户名和密码已设置好，通常的请求消息中 不包含用户名和密码，因此无法验证用户名和密码。因此， Web 服务器会向用户发送一条响应消息，
                告诉用户需要在请求消息中放入 用户名和密码。浏览器收到这条响应消息后，会弹出一个输入 用户名和密码的窗口，用户输入用户名和密码后，
                浏览器将这些信息放入请求消息中重新发送给服务器。然后，Web 服务器 查看接收到的用户名和密码与事先设置好的用户名和密码是否一致，
                以此 判断是否允许访问，如果允许访问，则返回数据

            </pre>
        </li>
        <li>
            <h3>返回响应消息</h3>
            <pre>
                首先，Web 服务器调用 Socket 库的 write，将响应消息交给协议栈。 这时，需要告诉协议栈这个响应消息应该发给谁，
                但我们并不需要直接告 知客户端的 IP 地址等信息，而是只需要给出表示通信使用的套接字的描述 符就可以了。
                套接字中保存了所有的通信状态，其中也包括通信对象的信 息，因此只要有描述符就万事大吉了。
                接下来，协议栈会将数据拆分成多个网络包，然后加上头部发送出去。 这些包中包含接收方客户端的地址，它们将经过交换机和路由器的转发，通过互联网最终到达客户端。
            </pre>
        </li>
        <li>
            <h3>浏览器接收响应消息并显示内容</h3>
            <pre>
                Web 服务器发送的响应消息会被分成多个包发送给客户端，然后客户 端需要接收数据。首先，网卡将信号还原成数字信息，协议栈将拆分的网 络包组装起来并取出响应消息，
                然后将消息转交给浏览器。这个过程和服 务器的接收操作相同。接下来，我们来看一看浏览器是如何显示内容的。
                要显示内容，首先需要判断响应消息中的数据属于哪种类型。Web 可 以处理的数据包括文字、图像、声音、视频等多种类型，
                每种数据的显 示方法都不同，因此必须先要知道返回了什么类型的数据，否则无法正 确显示。
                这时，我们需要一些信息才能判断数据类型，原则上可以根据响应消 息开头的 Content-Type 头部字段的值来进行判断。这个值一般是下面这样 的字符串。
                Content-Type: text/html
                其中“/”左边的部分称为“主类型”，表示数据的大分类;右边的“子 类型”表示具体的数据类型。在上面的例子中，主类型是 text，子类型是 html。
                主类型和子类型的含义都是事先确定好的；
                此外，当数据类型为文本时，还需要判断编码方式，这时需要用 charset 附加表示文本编码方式的信息，内容如下。
                Content-Type: text/html; charset=utf-8
                除了通过 Content-Type 判断数据类型，还需要检查 Content-Encoding 头部字段。
                如果消息中存放的内容是通过压缩或编码技术对原始数据进行 转换得到的，那么 Content-Encoding 的值就表示具体的转换方式，
                通过这 个字段的值，我们可以知道如何将消息中经过转换的数据还原成原始数据。

            </pre>
        </li>
    </ol>
    <ul>
        <li v-for="i of 11"><img :src="getImg('net',i)"/></li>
    </ul>
    </div>
    <script>
        new Vue({
            el:"#app",      
            methods:{
                getImg(name,i){
                    return "img/"+name+i+".jpg"
                }
            }
        })
    </script>
  </body>
</html>
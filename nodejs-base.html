<html>
    <head></head>
    <script src="vue.js"></script>
    <link type="text/css" rel="stylesheet" href="./css/main.css"/>  
    <body>
        <div id="app">
                <h2>css rendering stage</h2>
            <ol>               
                <li>    
                <h3>install version</h3>
                1. npm install sax@0.2.5 //install version 0.2.5 
                2. npm install sax@0.2.x //install the latest release of the 0.2 branch
                3. npm install sax@"<0.3" //install the latest version before 0.3
                4. npm install sax@">=0.1.0 <0.3.1" 
                
                </li>
                <li>
                    <h3>NPM global vs local</h3>
                    It’s possible that a module includes one or more executable files. 
                    If you choose to install a module globally and you used the default installation directory settings,
                    NPM installs the executables inside /usr/local/bin. This path is usually included in the default executable PATH environment variable.
                    If you installed a package locally, NPM installs any executables inside the ./node_modules/.bin directory.
                </li>              
                <li>
                    <h3>load folder process</h3>
                    var myModule = require('./myModuleDir');
                    If you do so, Node will search inside that folder. Node will presume this folder is a package and will try to look for a package definition. 
                    That package definition should be a file named package.json.
                    If that folder does not contain a package definition file named package.json, 
                    the package entry point will assume the default value of index.js, and Node will look, in this case, 
                    for a file under the path ./myModuleDir/index.js.
                    However, if you place a file named package.json inside the module directory,
                    Node will try to parse that file and look for and use the main attribute as a relative path for the entry point.
                    For instance, if your ./myModuleDir/package.json file looks something like the following,
                    Node will try to load the file with the path./myModuleDir/lib/myModule.js:
                    {
                    "name" : "myModule",
                    "main" : "./lib/myModule.js"
                    } 
                </li>
                <li>
                    <h3>buffer</h3>
                    Another thing that is special about this buffer class is that the memory where the data sits is allocated outside of the JavaScript VM memory heap. 
                    This means that these objects will not be moved around by the garbage-collection algorithm: It will sit in this permanent memory address without changing,
                    which saves CPU cycles that would be wasted making memory copies of the buffer contents.
                </li>
                <li>
                    <h3>tick</h3>
                    In Node, the event loop runs, as the name indicates, in a loop that processes the event queue. 
                    Every time the event loop executes, it’s called a tick.
                    You can schedule a callback function to be invoked on the next run of the event loop, that is, the next tick. 
                    Whereas setTimeout uses a JavaScript runtime that has its own scheduling queue,
                    the process.nextTick function is specific to the Node event loop.
                </li>
                <li>
                    <h3>http</h3>
                    One of the great features of Node is the ability to consume and produce streams easily from different sources. 
                    Because HTTP is a first-class protocol in Node, the HTTP responses are no different.
                    HTTP chunked encoding allows a server to keep sending data to the client without ever sending the bodysize.
                    Unless you specify a Content-Length header,the Node HTTPserver sends the following header to the client:
                    Transfer-Encoding: chunked
                    According to the HTTP specification, this header makes the client accept several chunks of data as the response body, 
                    sending a final chunk with a length of 0 before the client can terminate the response. 
                    This can be useful for streaming text, audio, or video data into the HTTP client.
                     
                </li>
            </ol>
           
        </div>
        
    </body>
</html>